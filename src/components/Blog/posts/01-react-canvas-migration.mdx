export const date = "2025-08-21";
export const title =
  "Migrating my 2-D platformer HTML/CSS/JS website to React";

I wanted to make coding more creative and build something I was excited about, so I designed [my personal website as a 2-D game platformer](https://lukemuehring.github.io/). It's loosely based on MapleStory, a 2-D platformer MMORPG. Rebuilding the game‚Äôs movement, animation, and collision mechanics brought back the nostalgia of a favorite childhood game.
\
In the beginning, I kept it simple with plain old HTML, CSS, and JS.
This approach was simple and easy. I could focus on creating fun features and learning fundamentals, rather than wasting time worrying about tooling problems with npm packages, CSS compiling order, and build configuration. üòñ\
\
My website consisted of:
- a simple HTML template with a `<canvas>` element for graphics
- a CSS file that stretched the `<canvas>` to the screen's size
- a JavaScript file containing the game logic

This worked for a while, but I ran into problems...

## Simple does not scale
As my website gained more features, the simple HTML CSS JS approach became exponentially more difficult to manage. My index.js became a monolith file that ballooned to almost 2,000 lines of spaghetti code. This sucked for many reasons:
1. *Constant scrolling between distant parts of the file*\
The sheer length of my 2,000 line `index.js` forced me to scroll a lot when making changes. This made it harder to keep mental context on function inputs, outputs, and what I'm trying to accomplish. I mitigated this problem by using a split screen to view different sections of the same file, but this approach prevented me from split screening with another file (like the styles). I like to work on my laptop most of the time, so the limited screen real estate didn't help either.

2. *CTRL + F works better when code is broken up*\
I would get 30+ matches with CTRL+F, since everything was defined in one file. If my project files were broken up, I'd have 10 or less matches to sift through. But with so many matches, it took me longer to find the exact spot I'm looking for.
    
3. *Abusing global context and technical debt*\
Since everything was in one file, I didn't worry about scope when defining variables. Which was awesome in the beginning! I would create a variable, and instantly be able to access it wherever I needed. It's very convenient. For example, if I was updating the `Camera` object to follow the `Player`, I could simply say `Player.x` anywhere in the code. I did the same thing for many other objects.
\
However, as the logic passed 1,000 lines, the game's objects became tightly coupled with hidden dependencies. A simple change to one variable cascaded into many side effects. Without explicitly defining dependencies in method headers and object constructors, it was hard to tell what, where and how things were being used. I would have to CTRL+F to find the references and parse through the functions' logic. Good thing everything was in one file üëç (I'm kidding).

On top of that, I was using plain JavaScript instead of TypeScript. As I created more objects like the `Camera`, `Map`, `Player`, etc. I began to see the need to encapsulate each object's logic, instead of flooding the same file with unrelated functions for every type of object.
\
\
The more spaghetti I had, the harder it was to untangle. And if I wanted to keep adding features, I had to bring order to the chaos.
## The Great Migration
I chose to migrate to Vite + React because:
- Unspaghettification: React components would help me organize the building blocks of my website into individual files.
- Experience: I wanted to use `npm` UI component [libraries](https://react-spectrum.adobe.com/react-spectrum/index.html) and deepen my experience with React. I felt that I had reinvented the wheel enough times when building my own UI components for [restandrelaxvacation.com](https://restandrelaxvacation.com/), and I wanted to create new features faster for my website (like this blog). Even though I develop with Angular for my current job, I had some previous experience with React at Microsoft, so I wanted to refresh those skills.

<small>There are some cons to using React though - besides more complex tooling, React adds around 40 kilobytes of code to the website's bundle size. According to my current wifi speed of 70 Mbps, that would take an additional 4ms to download. For reference, it takes 100ms to blink.</small>

\
Migrating from vanilla HTML / CSS / JS to React involved three steps:
1. Updating the HTML to use React's `main.tsx` and organizing the HTML and CSS into their own React component files.
2. Migrating the JavaScript game logic from the old `index.js` to a React component's `useEffect`

### 1. Updating the HTML
I changed index.html to point to React's main entry point: `main.tsx`.\
\
Old `index.html`: We get rid of DOM elements and move them into React components. 
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- metadata, favicon, stylesheet and font stuff -->
  </head>
  <body>
    <canvas id="canvas">
    </canvas>
    <nav id="nav">
    </nav>
    <div class="toast-container"></div>
    <script src="index.js"></script>
  </body>
</html>
```
\
New `index.html`: Just references the main entry point of the React app, `main.tsx`.
```html
<!DOCTYPE html>
<html lang="en">
  <head>
       <!-- metadata, favicon, stylesheet and font stuff -->
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```
\
I moved the `<canvas>` and `nav` elements into `App.tsx`, which React references when  `main.tsx` by convention. 
\
\
`main.tsx`
```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App.tsx";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode> 
);
```
\
`App.tsx`
```tsx
import MyCanvas from "./components/MyCanvas";
import "./style.css";

export default function App() {
  return (
    <>
      <MyCanvas />
      <nav id="nav">
      </nav>
      <div className="toast-container"></div>
    </>
  );
}
```
In my case I just kept my old `style.css` file and imported it here to keep the global styles.
\
\
Now I'll do a deep dive into `MyCanvas.tsx`, where we migrate the Javascript game logic.

## 2. Migrating index.js game logic
I migrated the Javascript logic from `index.js` to `MyCanvas.tsx` and separated it into three general sections:
1. Initializing global object refs
    \
    Here we initialize objects that are the main actors in the game. These are the Canvas, 2D Context for drawing, Player, and Map objects. They need to be shared across the game.
    \
    \
    `MyCanvas.tsx` 
    ```tsx
    export default function MyCanvas() {
      const CanvasRef = useRef<HTMLCanvasElement>(null);
      const ContextRef = useRef<CanvasRenderingContext2D | null>(null);

      const Bg0Ref = useRef<Background | null>(null);
      const Bg1Ref = useRef<Background | null>(null);
      const CameraRef = useRef<Camera | null>(null);
      const MapRef = useRef<GameMap | null>(null);

      //... the rest of MyCanvas.tsx
    }
    ```
    Here I am using React's `useRef` to store and remember global objects. By storing global objects in `useRef`, and not simply using pure Javascript objects, the global objects persist for the lifetime of the component, and rerenders of the component won't clear out the global objects.

2. Moving setup logic to useEffect()
    \
    React's `useEffect` runs after the main render function executes, after the `<canvas>` mounts in the DOM:
    ```tsx
    // main render function
    return (
        <canvas id="canvas" ref={CanvasRef}>
          <!-- accessibility stuff goes inside here if the client has Javascript disabled -->
        </canvas>
      );

    /*
    * Note - the ref={CanvasRef} on the <canvas> element is the React way of doing the following:
    * const CANVAS_DOM_ELEMENT = document.getElementById("canvas");
    */
    ```
    \
   It's the perfect place to initialize canvas drawing objects,  attach event listeners, and kick off the game loop. But before we can initialize the game objects, we have to define their object shapes. So I created classes for each major entity in my game. Here's an example for the `GameMap`:
    ```tsx
    // ./Components/GameMap.tsx
    export class GameMap {
      tsize: number;
      cols: number;
      rows: number;
      tiles: number[];
      length: number;

      constructor(tsize: number = 64, cols: number = 888, rows: number = 2) {
        this.tsize = tsize;
        this.cols = cols;
        this.rows = rows;

        this.tiles = new Array(this.cols * this.rows);
        this.tiles.fill(0, 0, this.cols);
        this.tiles.fill(1, this.cols);
        this.length = cols * tsize;
      }

      // getTile
      // Gets the tile index number (0,1,2...?) at the specified column and row
      // Returns undefined if the coordinates are out of bounds
      getTile(col: number, row: number): number | undefined {
        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
          return undefined;
        } 
        return this.tiles[row * this.cols + col];
      }
    }
    ```
    \
    Now that I have a class, I can call its constructor to initialize a new instance in the `useEffect`:
    ```tsx
        MapRef.current = new GameMap();
    ```
    \
    `useEffect` takes in a setup function to run after the component mounts. We can also define a clean up function that runs when the component unmounts, passed in the `return` of the `useEffect`. I used the cleanup function for removing event listeners. The `useEffect` also takes in an optional list of dependencies for rerenders as its second argument, but I left it empty. I make the call to get the first frame of the game once sprite images are finished preloading in `trackProgress`.
    ```tsx
    useEffect(() => {
        // Initialize the CanvasRef.current for rendering 2D graphics and init
        const canvas = CanvasRef.current;
        const c = canvas?.getContext("2d");
        if (!canvas || !c) {
          return;
        }

        // #region Preloading Images
        const imageCache: Record<string, HTMLImageElement> = {};
        const imagePathArray = [
          "./images/player/jump_0.png",
          "./images/player/stand1_0.png",
          "./images/player/stand1_1.png",
          "./images/player/stand1_2.png",
          "./images/player/walk1_0.png",
          "./images/player/walk1_1.png",
          "./images/player/walk1_2.png",
          "./images/player/walk1_3.png",
          "./images/grass1.png",
        ];

        let loadedImages = 0;

        function trackProgress() {
          loadedImages++;
          if (loadedImages === imagePathArray.length) {
            // Once all images are loaded, start the game loop with this call to window.requestAnimationFrame
            window.requestAnimationFrame(loop);
          }
        }

        function preloadImages() {
          for (let i = 0; i < imagePathArray.length; i++) {
            const tempImage = new Image();
            tempImage.addEventListener("load", trackProgress);
            tempImage.src = imagePathArray[i];
            imageCache[imagePathArray[i]] = tempImage;
          }
        }

        preloadImages();
        // #endregion

        // Set global singleton refs
        ContextRef.current = c;
        MapRef.current = new GameMap();
        CameraRef.current = new Camera(
          MapRef.current,
          c.canvas.width,
          c.canvas.height
        );

        // #region Background setup
        Bg0Ref.current = new Background({
          width: 1984,
          height: 1088,
          imageSrc: "./images/bg_0.png",
          moveRate: 0.3,
        });
        const Bg0 = Bg0Ref.current;
        // #endregion

        // Cleanup useEffect
        return () => {
          // Remove all event listeners on images to prevent leaks
          for (const src in imageCache) {
            imageCache[src].removeEventListener("load", trackProgress);
          }
        };
      }, []);
    ```
    \
    **Question: Why don't we just define `CanvasRef.current` at the top of the component? Why do we need `useEffect` at all?**
    \
    When React first calls the MyCanvas() component, the CanvasRef.current is still null because the JSX `<canvas ref={CanvasRef}>` hasn‚Äôt been mounted into the DOM yet.

    That means if you call `canvasRef.current.getContext("2d")` **outside of** `useEffect`, you‚Äôll just get null.

3. Migrating the main game loop() function
  \
  I defined the main game loop logic as a function in the React component. To begin the migration, I commented most of the code out and re-implemented the most basic parts to get it working step-by-step.
    ```tsx
    // #region --- Animation Loop ---
    function loop(timestamp: number) {
      // rename references just for readability
      const c: CanvasRenderingContext2D | null = ContextRef.current;
      const Map: GameMap | null = MapRef.current;
      const Bg0: Background | null = Bg0Ref.current;
      const Bg1: Background | null = Bg1Ref.current;
      const Camera: Camera | null = CameraRef.current;

      // calculate time elapsed since last frame
      const deltaTime: number = timestamp - prevTimestamp;
      if (deltaTime >= FRAME_DURATION && c && Map && Camera && Bg0 && Bg1) {
        prevTimestamp = timestamp - (deltaTime % FRAME_DURATION);

        /*
        * Responsive Scaling
        */
        if (
          window.innerWidth != c.canvas.width ||
          window.innerHeight != c.canvas.height
        ) {
          handleCanvasResize(c, Map, Camera);
        }

        // /*
        //  * Controller Input
        //  */
        // if (Player.y > Floor.height && userInputIsAllowed) {
        //   userInputIsAllowed = false;
        //   setTimeout(() => {
        //     Player.x = spawnX;
        //     Player.y = 0;
        //     Player.xVelocity = 0;
        //     Player.yVelocity = 0;
        //     userInputIsAllowed = true;
        //   }, 1000);
        // }

        // if (
        //   (Controller.up || Controller.left || Controller.right) &&
        //   userInputIsAllowed
        // ) {
        //   Controller.userInputRegistered = true;
        //   if (Controller.up && Player.state != PlayerStates.Jumping) {
        //     Player.yVelocity -= JumpHeight;
        //   }
        //   if (Controller.left) {
        //     Player.xVelocity -= 0.5;
        //   }

        //   if (Controller.right) {
        //     Player.xVelocity += 0.5;
        //   }
        // }

        // /*
        //  * Gravity and Friction
        //  */
        // Player.yVelocity += Gravity;
        // Player.x += Player.xVelocity;
        // Player.y += Player.yVelocity;

        // Player.xVelocity *= 0.9;

        // // If the xVelocity is close enough to 0, we set it to 0 for animation purposes.
        // if (Player.xVelocity <= 0.2 && Player.xVelocity >= -0.2) {
        //   Player.xVelocity = 0;
        // }
        // Player.yVelocity += 0.9;

        // /*
        //  * Floor Collision
        //  */
        // if (
        //   Player.y > Floor.height &&
        //   Player.x < Floor.rightX &&
        //   Player.x > Floor.leftX
        // ) {
        //   Player.y = Floor.height;
        //   Player.yVelocity = 0;
        // }

        // // Constraining Player to x range [0, Map Size]
        // Player.x = Math.max(0, Math.min(Player.x, Map.cols * Map.tsize));

        Camera.update();

        /*
        * Background Draw
        */
        c.save();
        c.fillStyle = "rgb(" + Bg1.color + ")";
        c.fillRect(0, 0, c.canvas.width, c.canvas.height);
        c.restore();

        drawBackground(c, Bg0);
        drawBackground(c, Bg1);

        // more commented out code...

        FrameCountRef.current++;
        if (FrameCountRef.current >= Number.MAX_SAFE_INTEGER) {
          FrameCountRef.current = 0;
        }
      }

      // Call next frame of animation
      window.requestAnimationFrame(loop);
    }
    // #endregion Animation Loop
      ```
    \
    Progressively upgrading the game made the whole migration more manageable and put it into bite-sized chunks, which helped a lot with maintainability. For example, I had a bunch of utility functions sitting in my `index.js` and didn't want to clutter my `MyCanvas.tsx`, so I created a `helpers.ts` file for these functions:
    ```tsx 
    // helpers.ts

    // draws the image but flips it horizontally
    export function drawFlippedImage(
      context: CanvasRenderingContext2D,
      image: HTMLImageElement,
      x: number,
      y: number
    ) {
      context.save();
      context.translate(x + image.width / 2, 0);
      context.scale(-1, 1);
      context.translate(-(x + image.width / 2), 0);
      context.drawImage(image, Math.floor(x), Math.floor(y));
      context.restore();
    }
    ```
    \
    It was fine to move these functions outside of the component since they were pure and didn't depend on React state.
    \
    \
    That's essentially how I performed the migration of my game website from Javascript to React + TypeScript!
    If you made it this far, thanks for reading!

{/* ## Additional React and JavaScript learnings from this migration
### When to use `useRef`
Let's say I have a boolean variable and I'm not sure how to store it. 
\
\
If the boolean is UI-related, and changes to the boolean's value should cause a rerender ‚Üí `useState`
\
Ex. a modal open/close flag. 
```tsx
const [isOpen, setIsOpen] = useState(false);
```
\
If the boolean is specific to the component instance, but should not cause a rerender on value changes ‚Üí `useRef`
\
Ex. the Player object
```tsx
PlayerRef: React.RefObject<Player | null>;
```
\
If the boolean is truly global (not specific to a React component) and non-reactive ‚Üí plain global `let`
\
Ex. a feature flag, or a debugging toggle used across modules.
```tsx
let debugMode = false;
```
### Note about Javascript bindings and `this`
In JavaScript there are two different kinds of functions you can put on a class:
1. A Normal Method
    ```tsx
    class Controller {
      keyListener(event: KeyboardEvent): void {
        console.log(this);
      }
    }
    ```
    Normal methods are stored on the prototype of the `Controller`. When `controller.keyListener(event)` is called, Javascript looks up `keyListener` on the prototype, then calls function with `this` set to the `controller` object. However, In Javascript, methods lose their `this` binding when they are passed as callbacks.
    \
    If you were to use the function as a callback, like so:
    ```tsx
    const fn = controller.keyListener;
    fn(event);
    ```
    \
    the `keyListener` callback is no longer associated with an object. So when the `console.log(this)` in the method body runs, `this` points to the global `window` (or in strict mode, is just `undefined`). This is bad if you are trying to access some instance data like `this.isUserInputAllowed`.
    \
    If you wanted the `keyListener`'s `this` to always be bound to the `controller` object, you would need to bind it explicitly in the `Controller` constructor:
    ```tsx
    export class Controller {
      constructor() {
        // ... constructor stuff ...
        this.keyListener = this.keyListener.bind(this);
      }

      keyListener(event: KeyboardEvent) {
        // ... method logic ...
      }
    }
    ```
\
The code makes sure that the function's `this` will always point to the specific instance that did `.bind`.



I created a `Controller` object to listen for keyboard `keydown` and `keyup` events so that I can react to a user's inputs. The `Controller` has a `keyListener` function that I pass as a callback to the event listener. With this setup, every `keydown` event triggers the `Controller.keyListener` function.
```tsx
// in useEffect()
const keydownListener = (event: KeyboardEvent) => {
      ControllerRef.current?.keyListener(event);
    };

window.addEventListener("keydown", keydownListener);
```
\
And here is the `Controller` class for user input, where we define the `keyListener` callback:
```tsx
export class Controller {
  left: boolean;
  right: boolean;
  up: boolean;
  userInputRegistered: boolean;
  closeMenuCallback?: () => void; // passed in function to handle 'esc' key presses

  constructor(closeMenuCallback?: () => void) {
    this.left = false;
    this.right = false;
    this.up = false;
    this.userInputRegistered = false;
    this.closeMenuCallback = closeMenuCallback;

    // Bind 'this' to be this Controller instance
    this.keyListener = this.keyListener.bind(this);
  }

  keyListener(event: KeyboardEvent): void {
    const keyState = event.type === "keydown";
    switch (event.key) {
      case "ArrowLeft":
        this.left = keyState;
        break;
      case "ArrowUp":
        this.up = keyState;
        break;
      case "ArrowRight":
        this.right = keyState;
        break;
      case "Escape":
        if (keyState) {
          this.closeMenuCallback?.();
        }
        break;
    }
  }
}
```
\
Arrow functions behave differently. Arrow functions don't have their own `this`, they "close over" whatever `this` was in the surrounding context where the arrow function was created. 

## Performance Optimizations and Benchmarking
 */}
